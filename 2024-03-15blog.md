由于电脑宕机，一上午努力白费，凭记忆恢复。
<style>
    button {
        background-color: #4CAF50; /* 背景色 */
        border: none; /* 边框大小 */
        color: white; /* 文字颜色 */
        padding: 5px 10px; /* 内边距 */
        text-align: center; /* 文字居中 */
        text-decoration: none; /* 文字下划线 */
        display: inline-block; /* 显示方式 */
        font-size: 13px; /* 字体大小 */
        margin: 4px 2px; /* 外边距 */
        cursor: pointer; /* 鼠标指针样式 */
        width: 120px; /* 设置按钮宽度为100像素 */
        height: 30px;
        border-radius: 5px;
    }
</style>
<script>
    function a(){
        if(document.getElementById("code").style.display=="none"){
            document.getElementById("code").style.display="flex";
            document.getElementById("aa").style.display="flex";
            document.getElementById("btn").innerHTML="隐藏完整AC代码";
        }
        else{
            document.getElementById("code").style.display="none";
            document.getElementById("aa").style.display="none";
            document.getElementById("btn").innerHTML="显示完整AC代码";
        }
    }
</script>
# [终于A了](https://www.luogu.com.cn/record/150892853)！！！太不容易了！！！
<button type="button" id="btn" onclick="a()">显示完整AC代码</button>
<div id="code" style="display:none">

```c++
#include<iostream>
#include<string>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<vector>
#include<map>
using namespace std;

// 用来存证词的结构体
/*
证词种类：
    1.I am guilty.
    2.I am not guilty.
    3.XXX is guilty.
    4.XXX is not guilty.
    5.Today is XXX.
*/
struct words{
	string w;   // 证词中的可变文字，如“XXX is guilty.”中的XXX
	int is_true // 证词真假
    int type;   // 证词种类
};

// 用来存人的结构体
struct people{
	string name;
	vector<words> hw;
};

map<string,int> pp;   // 人与索引的对应
map<string,int> week; // 星期与索引的对应
string weeks[7]={     // 索引与星期的对应（包含.是因为后面懒得去了）
	"Monday.",
    "Tuesday.",
    "Wednesday.",
    "Thursday.",
    "Friday.",
    "Saturday.",
    "Sunday."
};

void init_week(){
	week.insert(pair<string,int>("Monday",1));
	week.insert(pair<string,int>("Tuesday",2));
	week.insert(pair<string,int>("Wednesday",3));
	week.insert(pair<string,int>("Thursday",4));
	week.insert(pair<string,int>("Friday",5));
	week.insert(pair<string,int>("Saturday",6));
	week.insert(pair<string,int>("Sunday",7));	
}

int ans=-1; // 储存罪犯答案
int main(){
	int m,n,p,flag,falut_num,uk=0;
	init_week();
	string temp,nn,sp;
	cin>>m>>n>>p;
	people pe[m+10];
	int is_honest[m+10]; // 储存该人是否说真话。-1为不确定
	for(int i=0;i<m+10;i++){
		is_honest[i]=-1;
	}

	words te;            // 证词临时变量
	for(int i=0;i<m;i++){
		cin>>pe[i].name;
		is_honest[i]=-1;
		pp.insert(pair<string,int>(pe[i].name,i));
	}
	getchar(); // 有坑，见下
	getchar();

    // 输入证词循环
	for(int i=0;i<p;i++){
		getline(cin,temp);
        // 还是坑，见下
		while(temp[temp.length()-1]=='\r'||temp[temp.length()-1]=='\n'){
    		temp.erase(temp.length()-1,1);
		}

		nn=temp.substr(0,temp.find(' ')-1);                            // nn为说该证词的人
		te.is_true=-1;
		sp=temp.substr(temp.find(' ')+1,temp.length()-temp.find(' ')); // 证词内容
		if(sp=="I am guilty."){
			te.w=sp; // 其实type为1或2时string w没用
			te.type=1;
			pe[pp[nn]].hw.push_back(te);
		}
		else if(sp=="I am not guilty."){
			te.w=sp;
			te.type=2;
			pe[pp[nn]].hw.push_back(te);
		}
		else{
			if(sp.find(" is guilty.")!=-1){
				te.w=sp.substr(0,sp.length()-11);
				te.type=3;
				pe[pp[nn]].hw.push_back(te);
			}
			else if(sp.find(" is not guilty.")!=-1){
				te.w=sp.substr(0,sp.length()-15);
				te.type=4;
				pe[pp[nn]].hw.push_back(te);
			}
			else if(sp.find("Today is ")!=-1){
				te.w=sp.substr(9,sp.length()-1);
				te.type=5;
				pe[pp[nn]].hw.push_back(te);
			}
		}	
	}
	
	
    // 枚举开始
	for(int today=0;today<7;today++){
		for(int gu=0;gu<m;gu++){

			falut_num=0; // 初始化说假话的人数为0
			uk=0;        // 初始化未知的人数为0
            // 初始化每个人的真假
			for(int i=0;i<m+10;i++){
				is_honest[i]=-1;
			}

            // 给每个证言表真假
			for(int i=0;i<m;i++){
				for(int j=0;j<pe[i].hw.size();j++){
					if(pe[i].hw[j].type==1){
						if(i==gu){
							pe[i].hw[j].is_true=1;
						}
						else{
							pe[i].hw[j].is_true=0;
						}
					}
					else if(pe[i].hw[j].type==2){
						if(i==gu){
							pe[i].hw[j].is_true=0;
						}
						else{
							pe[i].hw[j].is_true=1;
						}
					}
					else if(pe[i].hw[j].type==3){
						if(pp[pe[i].hw[j].w]==gu){
							pe[i].hw[j].is_true=1;
						}
						else{
							pe[i].hw[j].is_true=0;
						}
					}
					else if(pe[i].hw[j].type==4){
						if(pp[pe[i].hw[j].w]==gu){
							pe[i].hw[j].is_true=0;
						}
						else{
							pe[i].hw[j].is_true=1;
						}
					}
					else if(pe[i].hw[j].type==5){
						if(pe[i].hw[j].w==weeks[today]){
							pe[i].hw[j].is_true=1;
						}
						else{
							pe[i].hw[j].is_true=0;
						}
					}
					
				}
				
			}
			

            // 判断枚举是否有效
			for(int i=0;i<m;i++){
				flag=0; // flag为1，此次枚举无效
				if(pe[i].hw.size()==0){
					uk++;
				}
				else{
					for(int j=0;j<pe[i].hw.size();j++){
						
						if(is_honest[i]==-1){
							is_honest[i]=pe[i].hw[j].is_true;
							if(pe[i].hw[j].is_true==0){
								falut_num++;
								if(falut_num>n){
									flag=1;
									break;
								}
							}
						}
						else{
							if(is_honest[i]!=pe[i].hw[j].is_true){
								flag=1;
								break;
							}
						}
						
					}
					if(flag){
						break;
					}
				}
				
			}
			
			if(n>falut_num+uk){
				flag=1;
			}
			if(flag==0){
				if(ans!=-1&&ans!=gu){
					cout<<"Cannot Determine";
					return 0;
				}
				
				ans=gu;
			}
			uk=0;
			flag=0;
		}
	}
	if(ans!=-1){
		cout<<pe[ans].name;
	}
	else{
		cout<<"Impossible";
	}

}
```

</div>
<div id="aa" style="display:none">
<a onclick="a()">收起</a>
</div>

***
这是一道有趣的模拟题，思路十分简单，由于数据量不大，可以枚举。首先枚举今天是星期几，然后再枚举罪犯，之后判断是否出现矛盾。

矛盾包括：
- 一个人既说假话又说真话。
- 说假话的人数大于题目规定说假话的人数。
- 说假话的人数加不知道说话真假的人数小于题目规定说假话的人数。

如果出现矛盾此次枚举无效，否则记录当前罪犯，进行下一次枚举，如果枚举出新的罪犯直接输出退出。
```c++
cout<<"Cannot Determine";
return 0;
```
如果所有都枚举完了还没有成功的枚举就输出`Impossible`否则输出罪犯的名字。